
    stages {
        
        stage('Check existing tag') {
             when {
                expression {
                    RELEASE_TAG = sh (script: 'git tag -l $RELEASE_VERSION',returnStdout: true).trim()
                    return RELEASE_TAG == params.RELEASE_VERSION
                }
            }
            steps {
             echo(">> Tag $RELEASE_VERSION already exists")

                sh 'git tag -d $RELEASE_VERSION'
            }
        }

        stage("Release setup") {
            steps {
             echo ">> RELEASE_VERSION: $params.RELEASE_VERSION"

             echo ">> Version update"

             withMaven(maven: 'MAVEN_ENV') {
                sh 'mvn versions:set -DnewVersion=$RELEASE_VERSION -DprocessAllModules -DgenerateBackupPoms=false'
                }

             echo ">> Commit the modified POM file and tag the release"
                sh('''
                    git config user.name 'aek'
                    git config user.email 'anicetkeric@outlook.com'
                    git add :/*pom.xml
                    git commit -m "Release $RELEASE_VERSION"
                    git tag -a $RELEASE_VERSION -m "New Tag $RELEASE_VERSION"

             ''')

                echo ">> Release setup successfully"
            }
        }


def TAG_SELECTOR = "UNINTIALIZED"
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh "mvn --batch-mode -U deploy"
                script {
                    TAG_SELECTOR = readMavenPom().getVersion()
                }
                sh "mvn versions:set -DnewVersion=${TAG_SELECTOR}"
                echo("TAG_SELECTOR=${TAG_SELECTOR}")
            }
        }
    }
}


--------------------------------------------

script {
                    env.DEPLOY_VERSION = sh(returnStdout: true, script: "docker run --rm -v '${env.WORKSPACE}':/repo:ro softonic/ci-version:0.1.0 --compatible-with package.json").trim()
                    env.DEPLOY_MAJOR_VERSION = sh(returnStdout: true, script: "echo '${env.DEPLOY_VERSION}' | awk -F'[ .]' '{print \$1}'").trim()
                    env.DEPLOY_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse HEAD | cut -c1-7").trim()
                    env.DEPLOY_BUILD_DATE = sh(returnStdout: true, script: "date -u +'%Y-%m-%dT%H:%M:%SZ'").trim()

                    env.DEPLOY_STACK_NAME = "${env.STACK_PREFIX}-v${env.DEPLOY_MAJOR_VERSION}"
                    env.IS_NEW_VERSION = sh(returnStdout: true, script: "[ '${env.DEPLOY_VERSION}' ] && echo 'YES'").trim()
                }



       stage("Create new version") {
            when {
                branch "master"
                environment name: "IS_NEW_VERSION", value: "YES"
            }

            steps {
                script {
                    sshagent(['ci-ssh']) {
                        sh """
                            git config user.email "ci-user@email.com"
                            git config user.name "Jenkins"
                            git tag -a "v${env.DEPLOY_VERSION}" \
                                -m "Generated by: ${env.JENKINS_URL}" \
                                -m "Job: ${env.JOB_NAME}" \
                                -m "Build: ${env.BUILD_NUMBER}" \
                                -m "Env Branch: ${env.BRANCH_NAME}"
                            git push origin "v${env.DEPLOY_VERSION}"
                        """
                    }
                }

                sh "docker login -u=$REGISTRY_AUTH_USR -p=$REGISTRY_AUTH_PSW ${env.REGISTRY_ADDRESS}"
                sh "docker-compose -f ${env.COMPOSE_FILE} build"
                sh "docker-compose -f ${env.COMPOSE_FILE} push"
            }
